21 - MonKey
-----------
This time an iOS app is given, `Monkey.ipa`. The first thing is to unzip the file using `unzip Monkey.ipa`. Then we want to have a look at the code of the application. I used the free demo version of hopper disassembler to do that [1]. It is limited in time usage per session so Id did the challenge in several sessions of 30 minutes.

First I noticed a function called `onBtnPressed`, this is hopper pseudo-code for this function:  
![](./21/01_screen01.png)

It could be summarized as follows:

- A user input is retrieved as text
- The length of the input must be 16 characters otherwise we stop
- The user input is modified using a function called `sub_a75c`
- A string is formed out of concatenation of 3 other strings `makybk`, `omo` and `oaenklo` to give `makybkomooaenklo`
- The modified input must be equal to `makybkomooaenklo` otherwise we stop
- At this point, the original input is retrieved and used as a key in the `Util aesDecrypt` function to decrypt some base64 encoded data
- Eventually, the decoded data is displayed as a PNG picture

What is now left to do is to find an input that is 16 characters long and that, when modified through the `sub_a75c`function, is equal to `makybkomooaenklo`. We should now examine this `sub_a75c` function. Here is hopper's pseudo-code:  
![](./21/02_screen02.png)

A side note here, this 32 bit (ARMv7) pseudo-code generated by hopper is wrong, it states `0x27fbc + r2 * 0x2`. In reality it should read `0x27fbc + r2 * 0x4`. This can be found in the 64 bit version of the disassembly or directly in the assembly code.

Now that this precision is made, what does the function do? It is looping 16 times and each time copies one character (8 bits) from `arg0` plus an offset into the memory space starting at `arg1`. From the previous function, we know that `arg0` is our user input and `arg1` is a free memory space. Let's have a look at the offsets defined at `0x27fbc`, they look like this:  
![](./21/03_screen03.png)

When taking one value out of four (increasing the counter by one in each loop of `sub_a75c`), we get the following offsets: `790f851a246ecd3b`. Knowing that the resulting string must be `makybkomooaenklo` we can construct a lookup table as follows:
```
7 m
9 a
0 k 
f y
8 b
5 k
1 o
a m
2 o
4 o
6 a
e e
c n
d k
3 l
b o
```

Now when putting this in the order from 0 to f we get the decryption key, `koolokambamonkey`. What is left to do is seeing how the decryption is made in the `aesDecrypt` function:  
![](./21/04_screen04.png)

We can compare the `CCCrypt` function call with the documentation (header file) at [2] to see that AES is used in ECB mode with PKCS7 padding. Then it is only a matter of a simple python script to get the egg:
```python
#!/usr/bin/python

import base64
from Crypto.Cipher import AES

b64_string = 'uG4+[CUT BY TROLLI101]vMav'

key = 'koolokambamonkey'
decryptor = AES.new(key, AES.MODE_ECB)
print(base64.b64encode(decryptor.decrypt(base64.b64decode(b64_string))))
```

The script is then called as follows:
```bash
$ python decrypt.py | base64 -d > egg21.png
```

And the egg is revealed:  
![](./21/egg21.png)

\[1\]: Hopper, <https://www.hopperapp.com/>  
\[2\]: CommonCryptor.h - Apple open Source, <https://opensource.apple.com/source/CommonCrypto/CommonCrypto-36064/CommonCrypto/CommonCryptor.h>
